
BobCar.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  0000032a  0000039e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000032a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  000003a0  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000003d0  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000000f0  00000000  00000000  00000410  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000d40  00000000  00000000  00000500  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000957  00000000  00000000  00001240  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000072d  00000000  00000000  00001b97  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001a4  00000000  00000000  000022c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000538  00000000  00000000  00002468  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000032e  00000000  00000000  000029a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000b0  00000000  00000000  00002cce  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 66 00 	jmp	0xcc	; 0xcc <__ctors_end>
   4:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
   8:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
   c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  10:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  14:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  18:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  1c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  20:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  24:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  28:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  2c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  30:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  34:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  38:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  3c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  40:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  44:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  48:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  4c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  50:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  54:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  58:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  5c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  60:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  64:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__bad_interrupt>
  68:	92 00       	.word	0x0092	; ????
  6a:	9e 00       	.word	0x009e	; ????
  6c:	8c 00       	.word	0x008c	; ????
  6e:	a0 00       	.word	0x00a0	; ????
  70:	8e 00       	.word	0x008e	; ????
  72:	9e 00       	.word	0x009e	; ????
  74:	9e 00       	.word	0x009e	; ????
  76:	96 00       	.word	0x0096	; ????
  78:	9e 00       	.word	0x009e	; ????
  7a:	9e 00       	.word	0x009e	; ????
  7c:	98 00       	.word	0x0098	; ????
  7e:	9e 00       	.word	0x009e	; ????
  80:	9e 00       	.word	0x009e	; ????
  82:	9e 00       	.word	0x009e	; ????
  84:	8a 00       	.word	0x008a	; ????
  86:	9e 00       	.word	0x009e	; ????
  88:	94 00       	.word	0x0094	; ????
  8a:	9e 00       	.word	0x009e	; ????
  8c:	9e 00       	.word	0x009e	; ????
  8e:	9e 00       	.word	0x009e	; ????
  90:	9e 00       	.word	0x009e	; ????
  92:	9c 00       	.word	0x009c	; ????
  94:	9e 00       	.word	0x009e	; ????
  96:	90 00       	.word	0x0090	; ????
  98:	9e 00       	.word	0x009e	; ????
  9a:	9e 00       	.word	0x009e	; ????
  9c:	9e 00       	.word	0x009e	; ????
  9e:	9e 00       	.word	0x009e	; ????
  a0:	9e 00       	.word	0x009e	; ????
  a2:	9e 00       	.word	0x009e	; ????
  a4:	9e 00       	.word	0x009e	; ????
  a6:	9e 00       	.word	0x009e	; ????
  a8:	9e 00       	.word	0x009e	; ????
  aa:	9e 00       	.word	0x009e	; ????
  ac:	9e 00       	.word	0x009e	; ????
  ae:	9e 00       	.word	0x009e	; ????
  b0:	9e 00       	.word	0x009e	; ????
  b2:	9e 00       	.word	0x009e	; ????
  b4:	9e 00       	.word	0x009e	; ????
  b6:	9e 00       	.word	0x009e	; ????
  b8:	9e 00       	.word	0x009e	; ????
  ba:	9e 00       	.word	0x009e	; ????
  bc:	9a 00       	.word	0x009a	; ????
  be:	05 01       	movw	r0, r10
  c0:	0a 01       	movw	r0, r20
  c2:	0f 01       	movw	r0, r30
  c4:	14 01       	movw	r2, r8
  c6:	19 01       	movw	r2, r18
  c8:	1e 01       	movw	r2, r28
  ca:	23 01       	movw	r4, r6

000000cc <__ctors_end>:
  cc:	11 24       	eor	r1, r1
  ce:	1f be       	out	0x3f, r1	; 63
  d0:	cf ef       	ldi	r28, 0xFF	; 255
  d2:	d8 e0       	ldi	r29, 0x08	; 8
  d4:	de bf       	out	0x3e, r29	; 62
  d6:	cd bf       	out	0x3d, r28	; 61

000000d8 <__do_copy_data>:
  d8:	11 e0       	ldi	r17, 0x01	; 1
  da:	a0 e0       	ldi	r26, 0x00	; 0
  dc:	b1 e0       	ldi	r27, 0x01	; 1
  de:	ea e2       	ldi	r30, 0x2A	; 42
  e0:	f3 e0       	ldi	r31, 0x03	; 3
  e2:	02 c0       	rjmp	.+4      	; 0xe8 <__do_copy_data+0x10>
  e4:	05 90       	lpm	r0, Z+
  e6:	0d 92       	st	X+, r0
  e8:	a2 30       	cpi	r26, 0x02	; 2
  ea:	b1 07       	cpc	r27, r17
  ec:	d9 f7       	brne	.-10     	; 0xe4 <__do_copy_data+0xc>
  ee:	0e 94 a2 00 	call	0x144	; 0x144 <main>
  f2:	0c 94 93 01 	jmp	0x326	; 0x326 <_exit>

000000f6 <__bad_interrupt>:
  f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000fa <CTRL_GetCommand>:
	UART_putstring(&message[0]);
}

enum commands CTRL_GetCommand(){
	char received_char;
	received_char = UART_read();
  fa:	0e 94 68 01 	call	0x2d0	; 0x2d0 <UART_read>
	
	switch(received_char){
  fe:	90 e0       	ldi	r25, 0x00	; 0
 100:	fc 01       	movw	r30, r24
 102:	e3 54       	subi	r30, 0x43	; 67
 104:	f1 09       	sbc	r31, r1
 106:	eb 32       	cpi	r30, 0x2B	; 43
 108:	f1 05       	cpc	r31, r1
 10a:	c0 f4       	brcc	.+48     	; 0x13c <CTRL_GetCommand+0x42>
 10c:	ec 5c       	subi	r30, 0xCC	; 204
 10e:	ff 4f       	sbci	r31, 0xFF	; 255
 110:	0c 94 8d 01 	jmp	0x31a	; 0x31a <__tablejump2__>
		case 'F':
			return FORWARD;
			break;
		case 'Q':
			return FORWARD_LEFT;
 114:	81 e0       	ldi	r24, 0x01	; 1
 116:	08 95       	ret
			break;
		case 'E':
			return FORWARD_RIGHT;
 118:	82 e0       	ldi	r24, 0x02	; 2
 11a:	08 95       	ret
			break;
		case 'G':
			return BACKWARDS;
 11c:	83 e0       	ldi	r24, 0x03	; 3
 11e:	08 95       	ret
			break;
		case 'Z':
			return BACKWARDS_LEFT;
 120:	84 e0       	ldi	r24, 0x04	; 4
 122:	08 95       	ret
			break;
		case 'C':
			return BACKWARDS_RIGHT;
 124:	85 e0       	ldi	r24, 0x05	; 5
 126:	08 95       	ret
			break;
		case 'S':
			return NEUTRAL;
 128:	86 e0       	ldi	r24, 0x06	; 6
 12a:	08 95       	ret
			break;
		case 'J':
			return POWER;
 12c:	87 e0       	ldi	r24, 0x07	; 7
 12e:	08 95       	ret
			break;
		case 'M':
			return LIGHTS_ON;
 130:	88 e0       	ldi	r24, 0x08	; 8
 132:	08 95       	ret
			break;
		case 'm':
			return LIGHTS_OFF;
 134:	89 e0       	ldi	r24, 0x09	; 9
 136:	08 95       	ret
			break;
		case 'X':
			return BEEP;
 138:	8a e0       	ldi	r24, 0x0A	; 10
 13a:	08 95       	ret
			break;
		default:
			return UNKNOWN;
 13c:	8b e0       	ldi	r24, 0x0B	; 11
 13e:	08 95       	ret
	char received_char;
	received_char = UART_read();
	
	switch(received_char){
		case 'F':
			return FORWARD;
 140:	80 e0       	ldi	r24, 0x00	; 0
			break;
		default:
			return UNKNOWN;
			break;
	}
 142:	08 95       	ret

00000144 <main>:
#include "powertrain.h"
#include <avr/io.h>

int main(void)
{
	DDRC = 0xFF;
 144:	8f ef       	ldi	r24, 0xFF	; 255
 146:	87 b9       	out	0x07, r24	; 7
	PORTC = (0 << PC0);
 148:	18 b8       	out	0x08, r1	; 8
	
	UART_init(9600, true, true);
 14a:	41 e0       	ldi	r20, 0x01	; 1
 14c:	61 e0       	ldi	r22, 0x01	; 1
 14e:	80 e8       	ldi	r24, 0x80	; 128
 150:	95 e2       	ldi	r25, 0x25	; 37
 152:	0e 94 28 01 	call	0x250	; 0x250 <UART_init>
	enum commands command;
	
	POWTR_Init();
 156:	0e 94 c3 00 	call	0x186	; 0x186 <POWTR_Init>
	{
		// read sensors
		
		
		// read commands from controller
		if(UART_available()){
 15a:	0e 94 62 01 	call	0x2c4	; 0x2c4 <UART_available>
 15e:	88 23       	and	r24, r24
 160:	e1 f3       	breq	.-8      	; 0x15a <main+0x16>
			command = CTRL_GetCommand();
 162:	0e 94 7d 00 	call	0xfa	; 0xfa <CTRL_GetCommand>
			if((int)command <= 7){
 166:	88 30       	cpi	r24, 0x08	; 8
 168:	c0 f7       	brcc	.-16     	; 0x15a <main+0x16>
				POWTR_SendCommand(command);
 16a:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <POWTR_SendCommand>
 16e:	f5 cf       	rjmp	.-22     	; 0x15a <main+0x16>

00000170 <Timer2_Init>:
 * Set compare value (PWM duty) for timer2
 * Params:
 *	compare_value: value to write to compare register (0-255)
 */
void Timer2_SetCounter(int compare_value){
	OCR2A = compare_value;
 170:	e0 eb       	ldi	r30, 0xB0	; 176
 172:	f0 e0       	ldi	r31, 0x00	; 0
 174:	80 81       	ld	r24, Z
 176:	83 68       	ori	r24, 0x83	; 131
 178:	80 83       	st	Z, r24
 17a:	e1 eb       	ldi	r30, 0xB1	; 177
 17c:	f0 e0       	ldi	r31, 0x00	; 0
 17e:	80 81       	ld	r24, Z
 180:	84 60       	ori	r24, 0x04	; 4
 182:	80 83       	st	Z, r24
 184:	08 95       	ret

00000186 <POWTR_Init>:
/* POWTR_init
 * Initialize motoros PWM, pins as outputs and set them to LOW
 */
void POWTR_Init(){
	// driving motor pins
	DDRD |= (1 << PIN_BWD);
 186:	54 9a       	sbi	0x0a, 4	; 10
	DDRC |= (1 << PIN_FWD);
 188:	3d 9a       	sbi	0x07, 5	; 7
	DDRB |= (1 << PIN_POWER);
 18a:	23 9a       	sbi	0x04, 3	; 4
	PORTD &= ~(1 << PIN_BWD);
 18c:	5c 98       	cbi	0x0b, 4	; 11
	PORTC &= ~(1 << PIN_FWD);
 18e:	45 98       	cbi	0x08, 5	; 8
	PORTB &= ~(1 << PIN_POWER);
 190:	2b 98       	cbi	0x05, 3	; 5
	
	// turning motor pins
	DDRD |= (1 << PIN_TURN_L);
 192:	57 9a       	sbi	0x0a, 7	; 10
	DDRB |= (1 << PIN_TURN_R);
 194:	20 9a       	sbi	0x04, 0	; 4
	PORTD &= ~(1 << PIN_TURN_L);
 196:	5f 98       	cbi	0x0b, 7	; 11
	PORTB &= ~(1 << PIN_TURN_R);
 198:	28 98       	cbi	0x05, 0	; 5
	
	Timer2_Init();
 19a:	0e 94 b8 00 	call	0x170	; 0x170 <Timer2_Init>
 19e:	08 95       	ret

000001a0 <POWTR_TurnLeft>:
/* POWTR_TurnLeft
 * Set motor driver inputs to rotate turning
 * motor left
 */
void POWTR_TurnLeft(){
	PORTD |= (1 << PIN_TURN_L);
 1a0:	5f 9a       	sbi	0x0b, 7	; 11
	PORTB &= ~(1 << PIN_TURN_R);
 1a2:	28 98       	cbi	0x05, 0	; 5
 1a4:	08 95       	ret

000001a6 <POWTR_TurnRight>:
/* POWTR_TurnRight
 * Set motor driver inputs to rotate turning
 * motor left
 */
void POWTR_TurnRight(){
	PORTD &= ~(1 << PIN_TURN_L);
 1a6:	5f 98       	cbi	0x0b, 7	; 11
	PORTB |= (1 << PIN_TURN_R);
 1a8:	28 9a       	sbi	0x05, 0	; 5
 1aa:	08 95       	ret

000001ac <POWTR_NoTurn>:

/* POWTR_NoTurn
 * Set motor driver inputs to 0 to not turn the wheels
 */
void POWTR_NoTurn(){
	PORTD &= ~(1 << PIN_TURN_L);
 1ac:	5f 98       	cbi	0x0b, 7	; 11
	PORTB &= ~(1 << PIN_TURN_R);
 1ae:	28 98       	cbi	0x05, 0	; 5
 1b0:	08 95       	ret

000001b2 <POWTR_DriveForward>:
/* POWTR_DriveForward
 * Set motor driver inputs to rotate 
 * driving motor forward
 */
void POWTR_DriveForward(){
	PORTC |= (1 << PIN_FWD);
 1b2:	45 9a       	sbi	0x08, 5	; 8
	PORTD &= ~(1 << PIN_BWD);
 1b4:	5c 98       	cbi	0x0b, 4	; 11
 * Set compare value (PWM duty) for timer2
 * Params:
 *	compare_value: value to write to compare register (0-255)
 */
void Timer2_SetCounter(int compare_value){
	OCR2A = compare_value;
 1b6:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
 1ba:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
 1be:	4e e6       	ldi	r20, 0x6E	; 110
 1c0:	42 9f       	mul	r20, r18
 1c2:	c0 01       	movw	r24, r0
 1c4:	43 9f       	mul	r20, r19
 1c6:	90 0d       	add	r25, r0
 1c8:	11 24       	eor	r1, r1
 1ca:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
 1ce:	08 95       	ret

000001d0 <POWTR_DriveBackward>:
/* POWTR_DriveBackward
 * Set motor driver inputs to rotate 
 * driving motor backward
 */
void POWTR_DriveBackward(){
	PORTC &= ~(1 << PIN_FWD);
 1d0:	45 98       	cbi	0x08, 5	; 8
	PORTD |= (1 << PIN_BWD);
 1d2:	5c 9a       	sbi	0x0b, 4	; 11
 * Set compare value (PWM duty) for timer2
 * Params:
 *	compare_value: value to write to compare register (0-255)
 */
void Timer2_SetCounter(int compare_value){
	OCR2A = compare_value;
 1d4:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
 1d8:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
 1dc:	4e e6       	ldi	r20, 0x6E	; 110
 1de:	42 9f       	mul	r20, r18
 1e0:	c0 01       	movw	r24, r0
 1e2:	43 9f       	mul	r20, r19
 1e4:	90 0d       	add	r25, r0
 1e6:	11 24       	eor	r1, r1
 1e8:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
 1ec:	08 95       	ret

000001ee <POWTR_Stop>:
 1ee:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
/* POWTR_Stop
 * Set motor driver inputs and timer counter to 0
 */
void POWTR_Stop(){
	Timer2_SetCounter(0);
	PORTC &= ~(1 << PIN_FWD);
 1f2:	45 98       	cbi	0x08, 5	; 8
	PORTD &= ~(1 << PIN_BWD);
 1f4:	5c 98       	cbi	0x0b, 4	; 11
 1f6:	08 95       	ret

000001f8 <POWTR_SendCommand>:
 * Params:
 *	command:	command from bluetooth module (of type enum command)
 *				related to powertrain
 */
void POWTR_SendCommand(enum commands command){
	switch(command){
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	87 30       	cpi	r24, 0x07	; 7
 1fc:	91 05       	cpc	r25, r1
 1fe:	38 f5       	brcc	.+78     	; 0x24e <POWTR_SendCommand+0x56>
 200:	fc 01       	movw	r30, r24
 202:	e1 5a       	subi	r30, 0xA1	; 161
 204:	ff 4f       	sbci	r31, 0xFF	; 255
 206:	0c 94 8d 01 	jmp	0x31a	; 0x31a <__tablejump2__>
		case FORWARD:
			POWTR_NoTurn();
 20a:	0e 94 d6 00 	call	0x1ac	; 0x1ac <POWTR_NoTurn>
			POWTR_DriveForward();
 20e:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <POWTR_DriveForward>
			break;
 212:	08 95       	ret
		case FORWARD_LEFT:
			POWTR_TurnLeft();
 214:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <POWTR_TurnLeft>
			POWTR_DriveForward();
 218:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <POWTR_DriveForward>
			break;
 21c:	08 95       	ret
		case FORWARD_RIGHT:
			POWTR_TurnRight();
 21e:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <POWTR_TurnRight>
			POWTR_DriveForward();
 222:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <POWTR_DriveForward>
			break;
 226:	08 95       	ret
		case BACKWARDS:
			POWTR_NoTurn();
 228:	0e 94 d6 00 	call	0x1ac	; 0x1ac <POWTR_NoTurn>
			POWTR_DriveBackward();
 22c:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <POWTR_DriveBackward>
			break;
 230:	08 95       	ret
		case BACKWARDS_LEFT:
			POWTR_TurnLeft();
 232:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <POWTR_TurnLeft>
			POWTR_DriveBackward();
 236:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <POWTR_DriveBackward>
			break;
 23a:	08 95       	ret
		case BACKWARDS_RIGHT:
			POWTR_TurnRight();
 23c:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <POWTR_TurnRight>
			POWTR_DriveBackward();
 240:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <POWTR_DriveBackward>
			break;
 244:	08 95       	ret
		case NEUTRAL:
			POWTR_NoTurn();
 246:	0e 94 d6 00 	call	0x1ac	; 0x1ac <POWTR_NoTurn>
			POWTR_Stop();
 24a:	0e 94 f7 00 	call	0x1ee	; 0x1ee <POWTR_Stop>
 24e:	08 95       	ret

00000250 <UART_init>:
	while(*StringPtr != 0x00)
	{
		UART_send(*StringPtr);
		StringPtr++;
	}
}
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	d6 2f       	mov	r29, r22
 256:	c4 2f       	mov	r28, r20
 258:	a0 e0       	ldi	r26, 0x00	; 0
 25a:	b0 e0       	ldi	r27, 0x00	; 0
 25c:	88 0f       	add	r24, r24
 25e:	99 1f       	adc	r25, r25
 260:	aa 1f       	adc	r26, r26
 262:	bb 1f       	adc	r27, r27
 264:	88 0f       	add	r24, r24
 266:	99 1f       	adc	r25, r25
 268:	aa 1f       	adc	r26, r26
 26a:	bb 1f       	adc	r27, r27
 26c:	9c 01       	movw	r18, r24
 26e:	ad 01       	movw	r20, r26
 270:	22 0f       	add	r18, r18
 272:	33 1f       	adc	r19, r19
 274:	44 1f       	adc	r20, r20
 276:	55 1f       	adc	r21, r21
 278:	22 0f       	add	r18, r18
 27a:	33 1f       	adc	r19, r19
 27c:	44 1f       	adc	r20, r20
 27e:	55 1f       	adc	r21, r21
 280:	60 e0       	ldi	r22, 0x00	; 0
 282:	74 e2       	ldi	r23, 0x24	; 36
 284:	84 ef       	ldi	r24, 0xF4	; 244
 286:	90 e0       	ldi	r25, 0x00	; 0
 288:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <__udivmodsi4>
 28c:	21 50       	subi	r18, 0x01	; 1
 28e:	31 09       	sbc	r19, r1
 290:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
 294:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
 298:	e2 ec       	ldi	r30, 0xC2	; 194
 29a:	f0 e0       	ldi	r31, 0x00	; 0
 29c:	80 81       	ld	r24, Z
 29e:	86 60       	ori	r24, 0x06	; 6
 2a0:	80 83       	st	Z, r24
 2a2:	dd 23       	and	r29, r29
 2a4:	29 f0       	breq	.+10     	; 0x2b0 <UART_init+0x60>
 2a6:	e1 ec       	ldi	r30, 0xC1	; 193
 2a8:	f0 e0       	ldi	r31, 0x00	; 0
 2aa:	80 81       	ld	r24, Z
 2ac:	80 61       	ori	r24, 0x10	; 16
 2ae:	80 83       	st	Z, r24
 2b0:	cc 23       	and	r28, r28
 2b2:	29 f0       	breq	.+10     	; 0x2be <UART_init+0x6e>
 2b4:	e1 ec       	ldi	r30, 0xC1	; 193
 2b6:	f0 e0       	ldi	r31, 0x00	; 0
 2b8:	80 81       	ld	r24, Z
 2ba:	88 60       	ori	r24, 0x08	; 8
 2bc:	80 83       	st	Z, r24
 2be:	df 91       	pop	r29
 2c0:	cf 91       	pop	r28
 2c2:	08 95       	ret

000002c4 <UART_available>:

bool UART_available()
{
	return (UCSR0A & (1<<RXC0));
 2c4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
}
 2c8:	88 1f       	adc	r24, r24
 2ca:	88 27       	eor	r24, r24
 2cc:	88 1f       	adc	r24, r24
 2ce:	08 95       	ret

000002d0 <UART_read>:

unsigned char UART_read()
{
	return UDR0;
 2d0:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 2d4:	08 95       	ret

000002d6 <__udivmodsi4>:
 2d6:	a1 e2       	ldi	r26, 0x21	; 33
 2d8:	1a 2e       	mov	r1, r26
 2da:	aa 1b       	sub	r26, r26
 2dc:	bb 1b       	sub	r27, r27
 2de:	fd 01       	movw	r30, r26
 2e0:	0d c0       	rjmp	.+26     	; 0x2fc <__udivmodsi4_ep>

000002e2 <__udivmodsi4_loop>:
 2e2:	aa 1f       	adc	r26, r26
 2e4:	bb 1f       	adc	r27, r27
 2e6:	ee 1f       	adc	r30, r30
 2e8:	ff 1f       	adc	r31, r31
 2ea:	a2 17       	cp	r26, r18
 2ec:	b3 07       	cpc	r27, r19
 2ee:	e4 07       	cpc	r30, r20
 2f0:	f5 07       	cpc	r31, r21
 2f2:	20 f0       	brcs	.+8      	; 0x2fc <__udivmodsi4_ep>
 2f4:	a2 1b       	sub	r26, r18
 2f6:	b3 0b       	sbc	r27, r19
 2f8:	e4 0b       	sbc	r30, r20
 2fa:	f5 0b       	sbc	r31, r21

000002fc <__udivmodsi4_ep>:
 2fc:	66 1f       	adc	r22, r22
 2fe:	77 1f       	adc	r23, r23
 300:	88 1f       	adc	r24, r24
 302:	99 1f       	adc	r25, r25
 304:	1a 94       	dec	r1
 306:	69 f7       	brne	.-38     	; 0x2e2 <__udivmodsi4_loop>
 308:	60 95       	com	r22
 30a:	70 95       	com	r23
 30c:	80 95       	com	r24
 30e:	90 95       	com	r25
 310:	9b 01       	movw	r18, r22
 312:	ac 01       	movw	r20, r24
 314:	bd 01       	movw	r22, r26
 316:	cf 01       	movw	r24, r30
 318:	08 95       	ret

0000031a <__tablejump2__>:
 31a:	ee 0f       	add	r30, r30
 31c:	ff 1f       	adc	r31, r31
 31e:	05 90       	lpm	r0, Z+
 320:	f4 91       	lpm	r31, Z
 322:	e0 2d       	mov	r30, r0
 324:	09 94       	ijmp

00000326 <_exit>:
 326:	f8 94       	cli

00000328 <__stop_program>:
 328:	ff cf       	rjmp	.-2      	; 0x328 <__stop_program>
